# Practice-3.1-3.5

## 1. Сортировка выбором
АНАЛИЗ РАБОТЫ АЛГОРИТМА:

Принцип работы:
Сортировка выбором работает по принципу разделения массива на две части:

· Отсортированная часть - в начале массива (изначально пустая)
· Неотсортированная часть - оставшаяся часть массива

Пошаговый процесс выполнения на примере массива [64, 25, 12, 22, 11]:

Итерация 1 (i = 0):

· Ищем минимальный элемент во всем массиве: min = 11 (индекс 4)
· Меняем местами arr[0] и arr[4]: [11, 25, 12, 22, 64]
· Теперь отсортированная часть: [11], неотсортированная: [25, 12, 22, 64]

Итерация 2 (i = 1):

· Ищем минимальный в неотсортированной части [25, 12, 22, 64]: min = 12 (индекс 2)
· Меняем местами arr[1] и arr[2]: [11, 12, 25, 22, 64]
· Отсортированная часть: [11, 12], неотсортированная: [25, 22, 64]

Итерация 3 (i = 2):

· Ищем минимальный в [25, 22, 64]: min = 22 (индекс 3)
· Меняем местами arr[2] и arr[3]: [11, 12, 22, 25, 64]
· Отсортированная часть: [11, 12, 22], неотсортированная: [25, 64]

Итерация 4 (i = 3):

· Ищем минимальный в [25, 64]: min = 25 (уже на месте)
· Массив остается: [11, 12, 22, 25, 64]

Результат: [11, 12, 22, 25, 64]

ОЦЕНКА ТРУДОЁМКОСТИ (НОТАЦИЯ BIG O):

Временная сложность:

1. Лучший случай: O(n²)
   · Даже если массив уже отсортирован, алгоритм все равно выполнит полные проходы
   · Всегда выполняется двойной цикл
2. Средний случай: O(n²)
   · В среднем требуется сравнить каждый элемент с половиной оставшихся элементов
3. Худший случай: O(n²)
   · Массив отсортирован в обратном порядке
   · Все равно выполняется полное количество сравнений

Математическое обоснование:
Количество сравнений = (n-1) + (n-2) + ... + 1 = n(n-1)/2 ∈ O(n²)

Пространственная сложность: O(1)

· Алгоритм сортирует массив "на месте" (in-place)
· Используется только несколько дополнительных переменных (i, j, minIndex)
· Не требует дополнительной памяти, пропорциональной размеру входных данных

Ключевые характеристики:

· Неустойчивая сортировка - может менять относительный порядок одинаковых элементов
· Медленный алгоритм для больших массивов из-за квадратичной сложности
· Простой в реализации и понимании
· Эффективен для небольших массивов или когда стоимость обмена высока

## 2. Сортировка обменом
ПОДРОБНЫЙ АНАЛИЗ РАБОТЫ АЛГОРИТМА:

Принцип работы:
Пузырьковая сортировка работает по принципу многократного прохода по массиву и сравнения соседних элементов. "Тяжелые" элементы постепенно "всплывают" в конец массива, как пузырьки в воде.

Пошаговый процесс выполнения на примере массива [5, 3, 8, 4, 2]:

Первый проход (i = 0):

· Сравниваем 5 и 3: 5 > 3 → меняем: [3, 5, 8, 4, 2]
· Сравниваем 5 и 8: 5 < 8 → не меняем: [3, 5, 8, 4, 2]
· Сравниваем 8 и 4: 8 > 4 → меняем: [3, 5, 4, 8, 2]
· Сравниваем 8 и 2: 8 > 2 → меняем: [3, 5, 4, 2, 8]
· Самый большой элемент (8) "всплыл" в конец

Второй проход (i = 1):

· Сравниваем 3 и 5: 3 < 5 → не меняем: [3, 5, 4, 2, 8]
· Сравниваем 5 и 4: 5 > 4 → меняем: [3, 4, 5, 2, 8]
· Сравниваем 5 и 2: 5 > 2 → меняем: [3, 4, 2, 5, 8]
· Второй по величине элемент (5) на своем месте

Третий проход (i = 2):

· Сравниваем 3 и 4: 3 < 4 → не меняем: [3, 4, 2, 5, 8]
· Сравниваем 4 и 2: 4 > 2 → меняем: [3, 2, 4, 5, 8]
· Третий элемент (4) на месте

Четвертый проход (i = 3):

· Сравниваем 3 и 2: 3 > 2 → меняем: [2, 3, 4, 5, 8]
· Массив полностью отсортирован

ОЦЕНКА ТРУДОЁМКОСТИ (НОТАЦИЯ BIG O):

Временная сложность:

1. Худший случай: O(n²)
   · Массив отсортирован в обратном порядке
   · Количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ∈ O(n²)
   · Количество обменов: такое же как сравнений
2. Средний случай: O(n²)
   · В среднем требуется n²/2 сравнений и n²/4 обменов
3. Лучший случай (обычная версия): O(n²)
   · Даже для уже отсортированного массива выполняются все проходы
4. Лучший случай (оптимизированная версия): O(n)
   · Для уже отсортированного массива достаточно одного прохода
   · Флаг swapped позволяет досрочно завершить сортировку

Пространственная сложность: O(1)

· Алгоритм сортирует "на месте"
· Используется только несколько дополнительных переменных (i, j, temp/swapped)
· Не требует дополнительной памяти, пропорциональной размеру входных данных

Ключевые характеристики:

· Устойчивая сортировка - сохраняет относительный порядок одинаковых элементов
· Очень медленный алгоритм для больших массивов
· Простой в реализации и понимании
· Хорош для обучения основам алгоритмов сортировки
· Эффективен только для очень маленьких массивов или почти отсортированных данных

Сравнение с сортировкой выбором:

· Пузырьковая: Много обменов, мало сравнений (в худшем случае n² обменов)
· Выбором: Мало обменов (ровно n-1), много сравнений (n² сравнений)
· Выбором обычно быстрее на практике из-за меньшего количества обменов

Практическое применение:
Используется в основном в образовательных целях. В реальных приложениях заменяется более эффективными алгоритмами (быстрая сортировка, сортировка слиянием и др.).

## 3. Сортировка вставками

ПОДРОБНЫЙ АНАЛИЗ РАБОТЫ АЛГОРИТМА:

Принцип работы:
Сортировка вставками работает по принципу обработки карт в руке. Мы начинаем с пустой "руки" (отсортированной части) и постепенно "вставляем" каждую новую карту в правильную позицию.

Пошаговый процесс выполнения на примере массива [12, 11, 13, 5, 6]:

Начальное состояние: Отсортированная часть: [12], Неотсортированная: [11, 13, 5, 6]

Итерация 1 (i = 1):

· Key = 11
· Сравниваем с 12: 11 < 12 → сдвигаем 12 вправо: [12, 12, 13, 5, 6]
· Дошли до начала → вставляем 11: [11, 12, 13, 5, 6]

Итерация 2 (i = 2):

· Key = 13
· Сравниваем с 12: 13 > 12 → вставляем сразу: [11, 12, 13, 5, 6]

Итерация 3 (i = 3):

· Key = 5
· Сравниваем с 13: 5 < 13 → сдвигаем 13: [11, 12, 13, 13, 6]
· Сравниваем с 12: 5 < 12 → сдвигаем 12: [11, 12, 12, 13, 6]
· Сравниваем с 11: 5 < 11 → сдвигаем 11: [11, 11, 12, 13, 6]
· Дошли до начала → вставляем 5: [5, 11, 12, 13, 6]

Итерация 4 (i = 4):

· Key = 6
· Сравниваем с 13: 6 < 13 → сдвигаем 13: [5, 11, 12, 13, 13]
· Сравниваем с 12: 6 < 12 → сдвигаем 12: [5, 11, 12, 12, 13]
· Сравниваем с 11: 6 < 11 → сдвигаем 11: [5, 11, 11, 12, 13]
· Сравниваем с 5: 6 > 5 → вставляем 6: [5, 6, 11, 12, 13]

Результат: [5, 6, 11, 12, 13]

ОЦЕНКА ТРУДОЁМКОСТИ (НОТАЦИЯ BIG O):

Временная сложность:

1. Худший случай: O(n²)
   · Массив отсортирован в обратном порядке
   · Каждый новый элемент нужно сдвигать через всю отсортированную часть
   · Количество операций: 1 + 2 + 3 + ... + (n-1) = n(n-1)/2 ∈ O(n²)
2. Средний случай: O(n²)
   · В среднем каждый элемент нужно сдвигать через половину отсортированной части
   · Количество операций: примерно n²/4
3. Лучший случай: O(n)
   · Массив уже отсортирован
   · Для каждого элемента выполняется только одно сравнение
   · Внутренний цикл while не выполняется никогда

Пространственная сложность: O(1)

· Алгоритм сортирует "на месте"
· Использует только константное количество дополнительной памяти (key, i, j)
· Очень эффективен по использованию памяти

ДЕТАЛЬНЫЙ АНАЛИЗ ПОВЕДЕНИЯ:

Преимущества:

· Адаптивный - работает быстрее на частично отсортированных массивах
· Стабильный - сохраняет порядок одинаковых элементов
· Онлайн-алгоритм - может сортировать массив по мере поступления данных
· Эффективен для маленьких массивов - на практике часто используется как часть гибридных алгоритмов
· Простой в реализации - интуитивно понятный алгоритм

Недостатки:

· Медленный для больших массивов - квадратичная сложность делает его неэффективным для больших n
· Много операций сдвига - может быть медленным при работе с linked lists

Оптимизации на практике:

1. Бинарный поиск для вставки - можно использовать бинарный поиск для нахождения позиции вставки (уменьшает сравнения, но не сдвиги)
2. Шелл-сортировка - использует идею сортировки вставками с предварительным частичным упорядочиванием
3. Гибридные алгоритмы - часто используется в комбинации с быстрой сортировкой для маленьких подмассивов

Сравнение с предыдущими алгоритмами:

· Пузырьковая: O(n²) в лучшем случае vs Вставками: O(n) в лучшем случае
· Выбором: Всегда O(n²) vs Вставками: Адаптивный, O(n) для отсортированных данных
· Вставками обычно быстрее на практике из-за адаптивности

Практическое применение:

· В стандартных библиотеках для сортировки маленьких массивов
· В алгоритмах типа Timsort (гибрид слияния и вставок)
· В реальном времени для потоковых данных
· В embedded systems из-за малого потребления памяти

Это полный разбор сортировки вставками. Продолжаем со следующим алгоритмом - сортировкой слиянием?





